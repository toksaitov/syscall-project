
COM 341, Operating Systems
==========================
# Project #1 Part #2: System Calls

Note: The process outlined below needs to be repeated for every CPU architecture.

### Initial Steps

1. Navigate to the directory containing the Debian hard drive image.

2. Launch Debian Linux in QEMU.

        ./start.sh

3. Start a new shell instance.

4. Transfer the `ish` directory from your machine to the emulated system using `scp` or Git.

5. Log into the Debian system via SSH using the credentials specified during the installation process.

        ssh -p 2222 <login>@127.0.0.1 # or ssh -p 2223 <login>@127.0.0.1

6. Change to the `ish` directory.

   In this task, you are required to execute a series of system calls to the Linux kernel, bypassing any standard libraries.

   The calls are:

        read
        chdir
        exit
        stat
        open
        creat
        dup2
        close
        fork
        execve
        waitpid
        write

   Included are sources for a simple shell that performs the calls above with the aid of a system library.

   Your objective is to implement the following functions:

        ish_read
        ish_chdir
        ish_exit
        ish_stat
        ish_open
        ish_creat
        ish_dup2
        ish_close
        ish_fork
        ish_execve
        ish_waitpid
        ish_write

   in `ish_syscalls.<arch>.c`, executing the system calls to the kernel directly. This will eliminate the dependency on the system library for the given shell.

   Access documentation for each corresponding system call to gather information on return values and parameter types.

        man 2 read
        man 2 write
        ...

   Library type definitions can be substituted as follows:

        typedef size_t  unsigned long
        typedef ssize_t long
        typedef pid_t   int

   The `struct stat` from `sys/stat.h` for the `stat` system call can be replaced with an array sufficiently large to hold file information from the kernel (since we are only interested in the return code). For an invalid pointer to a `struct stat`, the `stat` system call will always return an error.

        char stat[1024];

   Validate each custom system call function by substituting a related standard library call in `ish.c` with a call to your new implementation. Once everything is functioning as anticipated, revert the old system call names in `ish.c` and remove the `-D ISH_USE_STDLIB` preprocessor definition from the project's Makefile. Your shell will then utilize the new calls.

   Not every system call is available on all hardware platforms. In certain instances, you may need to find a replacement and modify the arguments in registers to execute the operation. For instance, `stat` might need to be replaced with `fstatat` or `open` with `openat`. To determine the appropriate calls to use, write a small C program to execute the call from C, then examine the assembly generated by the compiler. The GNU Debugger may prove useful in this scenario.

```c
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define BUFFER_SIZE 128
static char buffer[BUFFER_SIZE];

int main(int argc, char **argv[])
{
    /* All the ISH system calls in one place to disassemble them */

    int int_res __attribute__((used));
    ssize_t long_res __attribute__((used));

    long_res = read(0, buffer, BUFFER_SIZE);

    int_res = chdir("/tmp");

    struct stat statbuf;
    int_res = stat("/bin/true", &statbuf);

    int fd_open = open("/bin/false", 00000);

    int fd_creat = creat("/tmp/test.txt", 00644);

    int_res = dup2(fd_creat, 1);

    int_res = close(fd_open); int_res = close(fd_creat);

    pid_t pid;
    if ((pid = fork()) > 0) {
        int status;
        pid = waitpid(pid, &status, 0);
    } else {
        int_res = execve("/bin/ls", NULL, NULL);

        exit(42);
    }

    long_res = write(1, buffer, strnlen(buffer, BUFFER_SIZE));

    exit(43);

    return 0;
}
```

### Managing Sources and Executables

* Edit the code by adding implementations for each system call in the files `ish_syscall.<arch>.c`. Update the related system call names in `ish.c` to the newly implemented function names (e.g., change `read` to `ish_read`).

        vim ish_syscalls.<arch>.c
        vim ish.c

* Build or rebuild the shell using the command below:

        make

* Test the shell by executing built-in commands such as `cd` and `exit`. Attempt to launch various system programs like `ls` or `date` either with an absolute path to the executable or without it, and with or without parameters. Experiment with redirecting standard input or output streams using the `<` and `>` operators.

        ./ish
        /bin/ls
        /bin/ls -l /etc

  To exit, press `CTRL+C`.

        ./ish
        cd
        ls
        exit

        ./ish
        date
        exit

        ./ish
        cd /tmp
        ls > listing.txt
        cat < listing.txt
        exit 1

  Be aware that this is a simplified shell, lacking many features. For instance, you won't be able to edit your input, use piping, or have command autocomplete functionality.

  To test a specific system call, you'll need to determine which action in the shell engages that particular call under examination.

* Clean up by removing compiled files with the command below:

        make clean

* Do not forget to remove the `-D ISH_USE_STDLIB` preprocessor definition from the project's Makefile and revert `ish.c` to its original form before submission.

### Resources

* [GCC Documentation: How to Use Inline Assembly Language in C Code](https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html)
* [GCC-Inline-Assembly-HOWTO](https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html)
* [ARM GCC Inline Assembler Cookbook](http://www.ethernut.de/en/documents/arm-inline-asm.html)
* [Linux x86-64 System Call Tables](https://github.com/torvalds/linux/tree/master/arch/x86/entry/syscalls/syscall_64.tbl)
* [Bionic Standard C Library, Linux ARMv8-A System Call Table](https://github.com/android/platform_bionic/blob/master/libc/kernel/uapi/asm-generic/unistd.h)

### Documentation

    man 2 syscall
    man 2 syscalls

    man 2 read
    man 2 chdir
    man 2 exit
    ...

### Reading

* [C Books and Guides](https://github.com/auca/com.341/blob/master/Practice_Tasks/Tasks.md)
* _Understanding the Linux Kernel, Third Edition by Daniel P. Bovet and Marco Cesati, Chapters 4, 10_
* _Linux Kernel Development, Third Edition by Robert Love, Chapters 5, 7_
